<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Vòng tay với vị trí cố định</title>
    <link href="~/css/sortable.css" rel="stylesheet" />
    <link href="~/css/swal.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link rel="preconnect" href="https://ouroboroselio.blob.core.windows.net">
    <link rel="dns-prefetch" href="https://ouroboroselio.blob.core.windows.net">
    <style>
        /* Lazy loading placeholder */
        .charm-placeholder {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            min-height: 80px;
            border-radius: 8px;
        }

        @@keyframes loading {
            0%

        {
            background-position: 200% 0;
        }

        100% {
            background-position: -200% 0;
        }

        }

        .charm-item img {
            transition: opacity 0.3s ease;
            opacity: 0;
        }

            .charm-item img.loaded {
                opacity: 1;
            }

        /* Virtual scrolling container */
        .charm-container {
            height: 400px;
            overflow-y: auto;
            position: relative;
        }

        .charm-virtual-list {
            position: relative;
        }

        .charm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 10px;
        }

        /* Optimized image loading */
        .charm-item img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container1">
        <div>
            <div class="charm-list">
                <h3>✨ Danh sách Charm</h3>

                <!-- Virtual scrolling container -->
                <div class="charm-container" id="charmContainer">
                    <div class="charm-virtual-list" id="charmVirtualList">
                        <div class="charm-grid" id="availableCharms"></div>
                    </div>
                </div>
            </div>
            <div class="note-section">
                <h3>📝 Ghi chú</h3>
                <textarea id="noteInput" placeholder="Nhập ghi chú cho vòng tay của bạn..."></textarea>
                <p id="wordCount">Số từ: 0 / 200</p>
            </div>
        </div>
        <div class="ring">
            <h3>💍 Vòng tay (Tối thiểu 1 charm)</h3>
            <div id="bracelet"></div>
            <button id="submitBtn">Tạo vòng tay (kèm ghi chú)</button>
            <div id="totalPriceDisplay" style="margin-top: 15px; font-weight: bold;">
                Tổng giá vòng tay: 15.000đ
            </div>
            <div id="noteForUser" style="margin-top: 15px;">
                Lưu ý: Sản phẩm vòng tay bạn đã thiết kế đang tồn tại trong giỏ hàng sẽ bị xóa nếu bạn thiết kế 1 vòng tay khác thay thế!!!
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script>
        // =================== OPTIMIZED JAVASCRIPT - KEEP ORIGINAL UI ===================

        // 1. Enhanced performance variables
        let allCharms = [];
        let availableCharmsMap = new Map(); // For O(1) lookups instead of array.find()
        let usedCharmIds = new Set(); // Track used charms efficiently
        let renderedCharms = new Set(); // Track what's already rendered to avoid duplicates
        let shouldRerender = false; // Flag to control re-rendering

        // Keep original variables
        let filteredCharms = [];
        let visibleCharms = [];
        let currentPage = 0;
        const itemsPerPage = 12; // Reduced from 20 for better performance
        let isLoading = false;

        // 2. Enhanced image cache with size limits
        const imageCache = new Map();
        const maxCacheSize = 80; // Limit cache to prevent memory issues

        // Keep original DOM references
        const noteInput = document.getElementById("noteInput");
        const wordCount = document.getElementById("wordCount");
        const charmContainer = document.getElementById("charmContainer");
        const maxChars = 200;

        // 3. Intersection Observer for true lazy loading (NEW!)
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const src = img.dataset.src;
                    if (src && !img.src) {
                        loadImageOptimized(img, src);
                    }
                }
            });
        }, {
            rootMargin: '50px', // Start loading 50px before image comes into view
            threshold: 0.1
        });

        // 4. Optimized image loading function
        function loadImageOptimized(img, src) {
            // Check cache first
            if (imageCache.has(src)) {
                img.src = imageCache.get(src);
                img.classList.add('loaded');
                img.style.opacity = '1';
                return;
            }

            // Create temp image for preloading
            const tempImg = new Image();
            tempImg.onload = () => {
                // Manage cache size to prevent memory issues
                if (imageCache.size >= maxCacheSize) {
                    const firstKey = imageCache.keys().next().value;
                    imageCache.delete(firstKey);
                }
                imageCache.set(src, src);

                img.src = src;
                img.classList.add('loaded');
                img.style.opacity = '1';
                img.style.background = 'none';
                imageObserver.unobserve(img); // Stop observing after loading
            };

            tempImg.onerror = function() {
                img.style.display = 'none';
                const parent = img.parentNode;
                if (parent) {
                    parent.style.background = 'linear-gradient(45deg, #667eea, #764ba2)';
                    parent.style.color = 'white';
                    parent.style.display = 'flex';
                    parent.style.alignItems = 'center';
                    parent.style.justifyContent = 'center';
                    parent.style.fontSize = '12px';
                    parent.textContent = img.alt || 'Lỗi tải';
                }
                imageObserver.unobserve(img);
            };

            tempImg.src = src;
        }

        // 5. Debounce function for performance
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // 6. Optimized note input handler
        const debouncedNoteUpdate = debounce(() => {
            let currentLength = noteInput.value.length;
            if (currentLength > maxChars) {
                noteInput.value = noteInput.value.substring(0, maxChars);
                currentLength = maxChars;
            }
            wordCount.textContent = `Số ký tự: ${currentLength} / ${maxChars}`;
        }, 100);

        noteInput.addEventListener("input", debouncedNoteUpdate);

        // 7. Initialize data with performance optimization
        // Note: Replace this line with your actual data
        allCharms = @Html.Raw(Json.Serialize(ViewBag.Charms));
        // For demo purposes, using sample data:
        // allCharms = [
        //     {charmId: '1', name: 'Charm 1', price: 50000, imageUrl: 'https:via.placeholder.com/100x80/ff6b6b/ffffff?text=Charm+1'},
        //     {charmId: '2', name: 'Charm 2', price: 75000, imageUrl: 'https:via.placeholder.com/100x80/4ecdc4/ffffff?text=Charm+2'},
        //     {charmId: '3', name: 'Charm 3', price: 60000, imageUrl: 'https:via.placeholder.com/100x80/45b7d1/ffffff?text=Charm+3'},
        //     {charmId: '4', name: 'Charm 4', price: 80000, imageUrl: 'https:via.placeholder.com/100x80/f9ca24/ffffff?text=Charm+4'},
        //     {charmId: '5', name: 'Charm 5', price: 65000, imageUrl: 'https:via.placeholder.com/100x80/6c5ce7/ffffff?text=Charm+5'},
        //     {charmId: '6', name: 'Charm 6', price: 70000, imageUrl: 'https:via.placeholder.com/100x80/fd79a8/ffffff?text=Charm+6'}
        // ];

        filteredCharms = [...allCharms];

        // Build lookup maps for O(1) performance
        allCharms.forEach(charm => {
            availableCharmsMap.set(charm.charmId, charm);
        });

        // Keep original DOM references
        const availableCharmsDiv = document.getElementById('availableCharms');
        const braceletDiv = document.getElementById('bracelet');
        const slots = [];
        const totalSlots = 8;

        // 8. MASSIVELY optimized charm item creation
        function createCharmItem(charm) {
            const wrapper = document.createElement('div');
            wrapper.className = 'charm-wrapper';

            const div = document.createElement('div');
            div.className = 'charm-item';
            div.dataset.id = charm.charmId;

            // Create image with lazy loading
            const img = document.createElement('img');
            img.style.width = '100%';
            img.style.height = '80px';
            img.style.objectFit = 'cover';
            img.style.backgroundColor = '#f0f0f0';
            img.style.opacity = '0.3';
            img.style.background = 'linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)';
            img.loading = 'lazy';
            img.decoding = 'async';
            img.alt = charm.name;

            // Use dataset.src for lazy loading instead of immediate src
            img.dataset.src = charm.imageUrl;

            // Observe for lazy loading
            imageObserver.observe(img);

            div.appendChild(img);

            const price = document.createElement('div');
            price.className = 'charm-price';
            price.textContent = charm.price ? `${charm.price.toLocaleString('vi-VN')}đ` : 'Liên hệ';

            wrapper.appendChild(div);
            wrapper.appendChild(price);

            return wrapper;
        }

        // 9. Track used charms efficiently
        function updateUsedCharms() {
            usedCharmIds.clear();
            slots.forEach(slot => {
                if (slot.children.length > 0) {
                    const charmElement = slot.children[0];
                    const id = charmElement.dataset.id || charmElement.querySelector('.charm-item')?.dataset.id;
                    if (id) {
                        usedCharmIds.add(id);
                    }
                }
            });
        }

        // 10. Request re-render with debouncing
        const debouncedRender = debounce(() => {
            if (!shouldRerender) return;
            renderAvailableCharms(true);
            shouldRerender = false;
        }, 200);

        function requestRerender() {
            shouldRerender = true;
            debouncedRender();
        }

        // 11. HEAVILY optimized rendering function
        function renderAvailableCharms(reset = false) {
            if (reset) {
                availableCharmsDiv.innerHTML = '';
                visibleCharms = [];
                renderedCharms.clear();
                currentPage = 0;
            }

            // Use Set for O(1) lookup instead of array filtering
            updateUsedCharms();

            const availableCharms = allCharms.filter(charm => !usedCharmIds.has(charm.charmId));

            if (availableCharms.length === 0) {
                availableCharmsDiv.innerHTML = '<div class="empty-message">🎉 Không còn charm nào để chọn</div>';
                return;
            }

            // Only render new items that haven't been rendered yet
            const startIndex = currentPage * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, availableCharms.length);
            const itemsToRender = availableCharms.slice(startIndex, endIndex);

            if (itemsToRender.length === 0) return;

            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();

            itemsToRender.forEach(charm => {
                // Only create if not already rendered
                if (!renderedCharms.has(charm.charmId)) {
                    const charmItem = createCharmItem(charm);
                    fragment.appendChild(charmItem);
                    visibleCharms.push(charm);
                    renderedCharms.add(charm.charmId);
                }
            });

            availableCharmsDiv.appendChild(fragment);
            currentPage++;

            // Show load more button if there are more items
            if (endIndex < availableCharms.length) {
                const existingLoadMore = availableCharmsDiv.querySelector('.load-more-btn');
                if (existingLoadMore) {
                    existingLoadMore.remove();
                }

                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.textContent = `Xem thêm (${availableCharms.length - endIndex} charm)`;
                loadMoreBtn.className = 'load-more-btn';
                loadMoreBtn.style.cssText = 'width: 100%; padding: 10px; margin: 10px 0; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;';
                loadMoreBtn.onclick = () => {
                    loadMoreBtn.remove();
                    renderAvailableCharms(false);
                };
                availableCharmsDiv.appendChild(loadMoreBtn);
            }
        }

        // 12. Optimized scroll handling
        const throttledScroll = debounce(() => {
            if (charmContainer.scrollTop + charmContainer.clientHeight >= charmContainer.scrollHeight - 100) {
                if (!isLoading && currentPage * itemsPerPage < filteredCharms.length) {
                    isLoading = true;
                    // Use requestAnimationFrame for smooth performance
                    requestAnimationFrame(() => {
                        renderAvailableCharms(false);
                        isLoading = false;
                    });
                }
            }
        }, 100);

        charmContainer.addEventListener('scroll', throttledScroll);

        // 13. Optimized removeCharmFromSlot function
        function removeCharmFromSlot(charm) {
            const parentSlot = charm.parentNode;
            if (parentSlot && parentSlot.classList.contains('slot')) {
                parentSlot.removeChild(charm);
                updateTotalPrice();

                // Trigger optimized re-render
                requestRerender();
            }
        }

        // 14. Keep original createSlots function but optimize Sortable
        function createSlots() {
            braceletDiv.innerHTML = '';
            slots.length = 0;
            updateTotalPrice();

            const rope = document.createElement('div');
            rope.className = 'bracelet-rope';
            braceletDiv.appendChild(rope);

            const radius = 160;
            const centerX = braceletDiv.clientWidth / 2;
            const centerY = braceletDiv.clientHeight / 2;

            for (let i = 0; i < totalSlots; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.id = `slot-${i}`;
                slot.dataset.index = i;
                slot.textContent = `${i + 1}`;

                const angle = (i * 2 * Math.PI) / totalSlots - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle) - 35;
                const y = centerY + radius * Math.sin(angle) - 35;

                slot.style.left = `${x}px`;
                slot.style.top = `${y}px`;

                braceletDiv.appendChild(slot);
                slots.push(slot);

                // Optimized Sortable configuration
                new Sortable(slot, {
                    group: {
                        name: 'charms',
                        put: function(to, from) {
                            return to.el.children.length === 0 || from.el === to.el;
                        }
                    },
                    animation: 200, // Reduced from 300 for better performance
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    onAdd: function(evt) {
                        const slotEl = evt.to;
                        if (slotEl.children.length > 1) {
                            // Remove duplicates efficiently
                            while (slotEl.children.length > 1) {
                                slotEl.removeChild(slotEl.children[0]);
                            }
                        }

                        if (evt.from.id === 'availableCharms' || evt.from.closest('#availableCharms')) {
                            const charmItem = evt.item;
                            const id = charmItem.dataset.id || charmItem.querySelector('.charm-item')?.dataset.id;
                            const charm = availableCharmsMap.get(id); // O(1) lookup instead of array.find()

                            if (charm) {
                                const price = charmItem.querySelector('.charm-price');
                                if (price) {
                                    charmItem.removeChild(price);
                                }

                                const oldButton = charmItem.querySelector('button');
                                if (oldButton) {
                                    charmItem.removeChild(oldButton);
                                }

                                const btnRemove = document.createElement('button');
                                btnRemove.textContent = '×';
                                btnRemove.onclick = function(e) {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    removeCharmFromSlot(this.parentNode);
                                };
                                charmItem.appendChild(btnRemove);

                                charmItem.classList.remove('charm-item');
                                charmItem.classList.add('ring-item');

                                const image = charmItem.querySelector('img');
                                if (image) {
                                    image.style.maxWidth = '100%';
                                }
                            }
                        }
                        updateTotalPrice();
                        requestRerender(); // Use optimized re-render
                    },
                    onUpdate: function(evt) {
                        const charmItem = evt.item;
                        const oldButton = charmItem.querySelector('button');
                        if (oldButton) {
                            charmItem.removeChild(oldButton);
                        }

                        const btnRemove = document.createElement('button');
                        btnRemove.textContent = '×';
                        btnRemove.onclick = function(e) {
                            e.stopPropagation();
                            e.preventDefault();
                            removeCharmFromSlot(this.parentNode);
                        };
                        charmItem.appendChild(btnRemove);
                        updateTotalPrice();
                    }
                });
            }
        }

        // 15. Optimized price calculation with debouncing
        const debouncedPriceUpdate = debounce(() => {
            let totalPrice = 15000;
            for (let i = 0; i < slots.length; i++) {
                const slot = slots[i];
                if (slot.children.length > 0) {
                    const charmId = slot.children[0].dataset.id;
                    const charm = availableCharmsMap.get(charmId); // O(1) lookup
                    if (charm && charm.price) {
                        totalPrice += charm.price;
                    }
                }
            }
            const priceDisplay = document.getElementById('totalPriceDisplay');
            priceDisplay.textContent = `Tổng giá vòng tay: ${totalPrice.toLocaleString('vi-VN')}đ`;
        }, 50);

        function updateTotalPrice() {
            debouncedPriceUpdate();
        }

        // 16. Optimize Sortable for available charms (one-time setup)
        new Sortable(availableCharmsDiv, {
            group: {
                name: 'charms',
                pull: 'clone',
                put: false
            },
            sort: false,
            animation: 200, // Reduced animation time
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            onStart: function(evt) {
                const wrapper = evt.item;
                const charmItem = wrapper.querySelector('.charm-item');
                if (charmItem) {
                    evt.item.dataset.id = charmItem.dataset.id;
                }
            }
        });

        // 17. Keep original submit handler
        document.getElementById('submitBtn').onclick = () => {
            const selectedIds = [];
            for (let i = 0; i < slots.length; i++) {
                const slot = slots[i];
                if (slot.children.length > 0) {
                    selectedIds.push(slot.children[0].dataset.id);
                } else {
                    selectedIds.push("");
                }
            }

            const note = document.getElementById('noteInput').value.trim();
            const filledSlots = selectedIds.filter(id => id !== "").length;

            if (filledSlots === 0) {
                alert('🎯 Vui lòng đặt ít nhất 1 charm vào vòng tay trước khi gửi!');
                return;
            } else {
                Swal.fire({
                    title: 'Xác nhận thêm vào giỏ',
                    text: 'Bạn có muốn thêm vòng tay này vào giỏ hàng không?',
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: 'Thêm vào giỏ',
                    cancelButtonText: 'Hủy',
                    customClass: {
                        confirmButton: 'swal2-confirm',
                        cancelButton: 'swal2-cancel'
                    }
                }).then((result) => {
                    if (result.isConfirmed) {
                        console.log('Đang gửi vòng tay:', { note, selectedIds });
                        // Replace with your actual AJAX call
                        
                        $.ajax({
                            url: '/Custom/AddBraceletToCart',
                            type: 'POST',
                            contentType: 'application/json',
                            data: JSON.stringify({
                                note: note,
                                charmIds: selectedIds
                            }),
                            headers: {
                                'RequestVerificationToken': $('input[name="__RequestVerificationToken"]').val()
                            },
                            success: function (response) {
                                console.log('AJAX success:', response);
                                if (response.success) {
                                    Swal.fire({
                                        title: 'Thành công',
                                        text: 'Sản phẩm đã được thêm vào giỏ hàng.',
                                        icon: 'success',
                                        confirmButtonText: 'OK'
                                    }).then(() => {
                                        if (typeof updateCartCount === 'function') {
                                            updateCartCount();
                                        }
                                        window.location.href = 'https://ouroboroscustom-b3b0hpcwgfbxhhcy.southeastasia-01.azurewebsites.net/Cart/CartDetail';
                                    });
                                } else {
                                    Swal.fire({
                                        title: 'Lỗi',
                                        text: response.message || 'Không thể thêm vào giỏ hàng.',
                                        icon: 'error',
                                        confirmButtonText: 'Đóng'
                                    });
                                }
                            },
                            error: function (xhr, status, error) {
                                console.error('AJAX error:', status, error, xhr.responseText);
                                Swal.fire({
                                    title: 'Lỗi',
                                    text: 'Có lỗi xảy ra khi thêm sản phẩm vào giỏ hàng.',
                                    icon: 'error',
                                    confirmButtonText: 'Đóng'
                                });
                            }
                        });
                       

                        // Demo success message
                        // Swal.fire({
                        //     title: 'Thành công',
                        //     text: 'Sản phẩm đã được thêm vào giỏ hàng (Demo).',
                        //     icon: 'success',
                        //     confirmButtonText: 'OK'
                        // });
                    }
                });
            }
        };

        // 18. Initialize everything efficiently
        function initializeOptimized() {
            createSlots();
            requestRerender();
        }

        // Start the optimized app
        requestAnimationFrame(initializeOptimized);

        // =================== END OPTIMIZATIONS ===================
    </script>
</body>
</html>